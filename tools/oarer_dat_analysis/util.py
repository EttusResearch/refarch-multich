
#
# Copyright 2010-2012,2014-2015 Ettus Research LLC
# Copyright 2021 Ettus Research, a National Instruments Company
#
# SPDX-License-Identifier: GPL-3.0-or-later
#

from asyncio.subprocess import PIPE
import os
import logging as log
import numpy as np
import glob 
import configargparse, argparse
import shutil
from usrpDat import *
from usrpDat import usrpDat
from util import *
import os
import subprocess
import pathlib
from plots import *

def parse_args():
    description = "This utility allows for the viewing of dat files generated by the OARER architecture."
    parser = configargparse.ArgParser(formatter_class=argparse.RawTextHelpFormatter,
                                     description=description, default_config_files=['~/*.conf'])
    parser.add_argument("-filename", type=str, default=None,help="Name of the input file.")
    parser.add_argument("-folder", type=str, default=None,  help="Folder to search for newest .dat files.")
    parser.add_argument("-fs", type=str, default=33330000.0, help="Sampling Rate of Data.")
    parser.add_argument("-start-point", type=int, default=0,help="Starting point of plots, must be multiple of number of samples.")
    parser.add_argument("-end-point", type=int, default=0,help="Ending point of plots")
    parser.add_argument("-format", type=str, default="int16", help="Data Format, default: int16")
    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("-base-rx",type=str, default="rx_00", help="Base RX channel to measure against, format: rx_##")
    parser.add_argument('-ppw', type=int, default=500, help='Points Per Window')
    args = parser.parse_args()
    return args

def get_iq_object(filename, datatype, filesize):
   
    _, file_extension = os.path.splitext(filename)
    
    if file_extension.lower() == '.dat':
        log.info('This is a USRP .dat file.')
        iq_data = usrpDat(filename = filename, datatype=datatype , filesize = filesize)
    else:
        log.info('Please use a valid .dat filetype.')
        
    return iq_data

def get_newest_folder(mnt):
    #Search directory for newest folder 
    folders = glob.glob(mnt+"*")
    fileFolder = max(folders, key=os.path.getctime)
    return fileFolder

def get_last_num_folders(mnt, numfolders):
    folder_list = []
    for x in range(1,numfolders+1):
        folders = sorted(pathlib.Path(mnt).glob('*/'), key=os.path.getmtime)[-x]
        folder_list.append(folders)


    return folder_list

def get_file_list(folder):
    dir_list = os.listdir(folder)
    return dir_list
        
def calculate_ptp_alignment_all(usrpDataDict: dict, baseRX, points_per_window):
    result = {}
    average_alignment = {}
    for key in usrpDataDict:       
        if key != baseRX:
            log.info("Calculating Alignment: " + baseRX + " to " + key)
            alignment = np.angle(np.conj(usrpDataDict[baseRX].complex_data) * usrpDataDict[key].complex_data, True)
            result[key] = alignment
            i = 0
            average_alignment[key] = np.average(alignment.reshape(-1, points_per_window), axis=1)


    return result, average_alignment
#TODO: FIX THIS FOR PATHS
def create_plot_directories(identifier: str):
    # Create temp directory if it does not exist.
    log.info("Creating Directories")
    if identifier:
        identifier = identifier
    else:
        identifier = ''
    if (os.path.exists(os.getcwd()+"/" + identifier)):
        shutil.rmtree( os.getcwd()+"/" + identifier )
    os.mkdir(os.getcwd()+"/" + identifier )
    os.mkdir(os.getcwd()+"/" + identifier + "/ptp_alignment/")
    os.mkdir(os.getcwd()+"/" + identifier + "/samples/")
    os.mkdir(os.getcwd()+"/" + identifier + "/phase_average/")

def run_cpp_example(build_path: str, exe_name: str, cfgFile: str):
    #Call RefArch and save data
    os.chdir(build_path)
    p = subprocess.Popen(["./"+exe_name,"--cfgFile="+cfgFile], shell=False)
    out, err = p.communicate()
    errcode = p.returncode
    print(errcode)
    p.kill()
    p.terminate()


def read_in_folders(path1 : str, path2 = ""):
    #Read in one or two seperate folders
    #This assumes you have setup the RefArch to have one or two RAID arrays
    #A path to each RAID array would be passed to this function.
    #This would need to be modified for more than two RAID arrays or file locations. 
    args = parse_args()
    folder_list=[]
    log.info("Reading in folder: {}.".format(path1))
    filefolder1 = get_newest_folder(path1)
    folder_list.insert(0,filefolder1)
    if path2 != "":
        log.info("Reading in folder: {}.".format(path2))
        filefolder2 = get_newest_folder(path2)
        folder_list.insert(1, filefolder2)
    iq_data_dict = {}
    complex_dict = {}
    for folder in folder_list:
        for file in os.listdir(folder):
            log.info("File {} selected.".format(file))
            filesize = os.path.getsize(str(folder) + '/' + file)
            iq_data = get_iq_object(file, args.format, filesize, args)
            iq_data.folder = str(folder)
            iq_data.fs = float(args.fs)
            iq_data.read_samples(args.format, args.start_point)
            iq_data.determine_nsamps()
            if iq_data.nsamples % args.ppw != 0:
                sys.exit("ERROR: PPW ("+str(args.ppw)+") must be multiple of nsamps: " + str(iq_data.nsamples))
            iq_data.deinterleave_iq()
            iq_data.convert_to_complex()
            iq_data_dict[iq_data.rx_channel_number] = iq_data
            # Convert data to complex and save to dict. 
            complex_dict[iq_data.rx_channel_number] = iq_data.complex_data 
    return iq_data_dict, complex_dict


def batch_folder_import(path0: str, numfolders = 1, datatype = "int16", start_point = 1000, fs = 33330000.0, ppw = 500 ):
    #Read in first path
    log.info("Reading in folder: {}.".format(path0))
    folderlist0 = get_last_num_folders(path0, numfolders)
    

    
    path0_folderdict = {} #dicts with run folders as keys, contain dicts of data with RX channels as keys
   

    # Read in data from path1
    for folder0 in folderlist0:
        # IQ Data Dicts with RX channels as keys
        file_data_dict0 ={}
        for file in os.listdir(folder0):
            filesize = os.path.getsize(str(folder0) + '/' + file)
            # IQ Data for file
            iq_data = get_iq_object(file, datatype, filesize)
            iq_data.folder = str(folder0)
            iq_data.fs = float(fs)
            iq_data.read_samples(datatype, start_point)
            iq_data.determine_nsamps()
            if iq_data.nsamples % ppw != 0:
                sys.exit("ERROR: PPW ("+str(ppw)+") must be multiple of nsamps: " + str(iq_data.nsamples))
            iq_data.deinterleave_iq()
            iq_data.convert_to_complex()
            file_data_dict0[iq_data.rx_channel_number] = iq_data
            
            path0_folderdict[folder0] = file_data_dict0
        
    

    #for k, v in path2_filedict.items():
        #print(k,v)
    

    return path0_folderdict

def batch_analyze_plot(dict0 : dict, ppw, numfolders = 1, base_rx = "rx_00"):
    for k_folder, v_folder in dict0.items():
        alignment, avg_alignment = calculate_ptp_alignment_all(v_folder, base_rx, ppw)
        create_plot_directories_tests(str(k_folder))
        #TODO: Finish 
        for data in alignment:
            plot_ptp_average(iq_data_dict[data], iq_data_dict[args.base_rx], avg_alignment, "temp", args.start_point, args.end_point, args.pps)
            plot_ptp_alignment(iq_data_dict[data], iq_data_dict[args.base_rx], alignment, "temp", args.start_point, args.end_point)
        for data in iq_data_dict:
            if data != args.base_rx:
                plot_samps(iq_data_dict[data], iq_data_dict[args.base_rx], "temp",  args.start_point, args.end_point)

    

def create_plot_directories_tests(identifier: str):
    # Create temp directory if it does not exist.
    log.info("Creating Directories")
    os.mkdir(identifier + "/ptp_alignment/")
    os.mkdir(identifier + "/samples/")
    os.mkdir(identifier + "/phase_average/")


