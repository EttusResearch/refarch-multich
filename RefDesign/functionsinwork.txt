void ReplayControl::replayTransmit(GraphSettings& graphSettings, SignalSettings& signalSettings){
    //Individual channel replay transmit
    //TBD


    uhd::time_spec_t now = graphSettings.graph->get_mb_controller(0)->get_timekeeper(0)->get_time_now();
    graphSettings.time_spec = uhd::time_spec_t(now + signalSettings.rtime);

    if (signalSettings.nsamps <= 0){
        //replay the entire buffer over and over
        std::cout << "Issuing replay command for " << signalSettings.samples_to_replay << " samps in continuous mode..." << std::endl;
        // Replay nsamps, wrapping back to the start of the buffer if nsamps is
        // larger than the buffer size.
        graphSettings.replay_ctrls[signalSettings.singleTX]->config_play(graphSettings.replay_buff_addr, graphSettings.replay_buff_size, graphSettings.replay_chan_vector[signalSettings.singleTX]);
        
        uhd::stream_cmd_t stream_cmd(uhd::stream_cmd_t::STREAM_MODE_START_CONTINUOUS);
        stream_cmd.num_samps = signalSettings.nsamps;
        stream_cmd.stream_now = false;
        stream_cmd.time_spec = graphSettings.time_spec;
        graphSettings.replay_ctrls[signalSettings.singleTX]->issue_stream_cmd(stream_cmd, graphSettings.replay_chan_vector[signalSettings.singleTX]);
        
    }
    else{
        std::cout << graphSettings.replay_ctrls[signalSettings.singleTX]->get_block_id() << " Port: " << graphSettings.replay_chan_vector[signalSettings.singleTX] <<  std::endl;
        std::cout << graphSettings.replay_ctrls[signalSettings.singleTX]->get_block_id() << " Issuing replay command for " << signalSettings.nsamps << " samps..." << std::endl;

         // Replay nsamps, wrapping back to the start of the buffer if nsamps is
        // larger than the buffer size.
        graphSettings.replay_ctrls[signalSettings.singleTX]->config_play(graphSettings.replay_buff_addr, graphSettings.replay_buff_size, graphSettings.replay_chan_vector[signalSettings.singleTX]);
        
        uhd::stream_cmd_t stream_cmd(uhd::stream_cmd_t::STREAM_MODE_NUM_SAMPS_AND_DONE);
        stream_cmd.num_samps = signalSettings.nsamps;
        stream_cmd.stream_now = false;
        stream_cmd.time_spec = graphSettings.time_spec;
        graphSettings.replay_ctrls[signalSettings.singleTX]->issue_stream_cmd(stream_cmd, graphSettings.replay_chan_vector[signalSettings.singleTX]);

    }

   
}

void ReplayControl::rfnocReceive(GraphSettings& graphSettings, double startTime){
    //individual channel rfnoc receive
    //TBD

}

 int ReplayControl::multithreadLoopback(GraphSettings& graphSettings, SignalSettings& signalSettings, DeviceSettings& deviceSettings){

        boost::thread_group recv_threads;
        boost::thread_group write_threads;

         std::vector<size_t> rx_channel_nums;

         rx_channel_nums.push_back(0);
    
        std::vector<std::vector<std::complex<short>>> buffs(160, std::vector<std::complex<short>>(signalSettings.spb));

        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue0;
        boost::atomic<bool> done0 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue1;
        boost::atomic<bool> done1 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue2;
        boost::atomic<bool> done2 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue3;
        boost::atomic<bool> done3 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue4;
        boost::atomic<bool> done4 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue5;
        boost::atomic<bool> done5 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue6;
        boost::atomic<bool> done6 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue7;
        boost::atomic<bool> done7 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue8;
        boost::atomic<bool> done8 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue9;
        boost::atomic<bool> done9 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue10;
        boost::atomic<bool> done10 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue11;
        boost::atomic<bool> done11 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue12;
        boost::atomic<bool> done12 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue13;
        boost::atomic<bool> done13 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue14;
        boost::atomic<bool> done14 (false);
        boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> ptr_queue15;
        boost::atomic<bool> done15 (false);
         
        std::vector<boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>>> queue_vector;
        queue_vector.reserve(32);
        std::vector<boost::atomic<bool>> done_vector;
        done_vector.reserve(32);

        for (int i = 0; i < graphSettings.radio_ctrls.size(); i++){
            //Create Vector of Queues and Atomic-Done indicators
            boost::lockfree::spsc_queue<recvStruct, boost::lockfree::capacity<100>> queue;
            boost::atomic<bool> done (false);
            queue_vector.emplace_back(boost::ref(queue));
            done_vector.emplace_back(boost::ref(done));

        }

       

        

        //Adjust Time so TXRX is synchronized across all channels
        uhd::time_spec_t now = graphSettings.graph->get_mb_controller(0)->get_timekeeper(0)->get_time_now();
        graphSettings.time_spec = uhd::time_spec_t(now + signalSettings.rtime);


        if (signalSettings.singleTXRX_loopback == false){
            if (signalSettings.format == "sc16"){
                for (int i = 0; i < graphSettings.rx_stream_vector.size(); i++){
                    std::cout << "Spawning RX Thread.." << i << std::endl;
                    recv_threads.create_thread(std::bind(&recvThread, graphSettings.rx_stream_vector[i],  signalSettings, signalSettings.nsamps, signalSettings.time_requested,  
                    graphSettings, signalSettings.spb, graphSettings.time_spec, signalSettings.format, signalSettings.otw,  rx_channel_nums,  signalSettings.rx_timeout, deviceSettings.rx_rate, i, queue_vector, done_vector));

                    std::cout << "Spawning Write Thread.." << i << std::endl;
                    write_threads.create_thread(std::bind(&writeThread,  signalSettings.rx_file, i, signalSettings.singleTX, 0,  deviceSettings, signalSettings, signalSettings.spb, queue_vector, done_vector));
                }
        
            }
            else {
                    
                    throw std::runtime_error("Unknown type " + signalSettings.format);
            }

        }
        else{
            if (signalSettings.format == "sc16"){
                for (int i = 0; i < 1; i++){
                    std::cout << "Spawning RX Thread.." << i << std::endl;
                    recv_threads.create_thread(std::bind(&recvThread, graphSettings.rx_stream_vector[signalSettings.singleRX],  signalSettings, signalSettings.nsamps, signalSettings.time_requested,  
                    graphSettings, signalSettings.spb, graphSettings.time_spec, signalSettings.format, signalSettings.otw,  rx_channel_nums,  signalSettings.rx_timeout, deviceSettings.rx_rate, i, queue_vector, done_vector));

                    std::cout << "Spawning Write Thread.." << i << std::endl;
                    write_threads.create_thread(std::bind(&writeThread,  signalSettings.rx_file, i, signalSettings.singleTX, 0,  deviceSettings, signalSettings, signalSettings.spb, queue_vector, done_vector));
        
                }
            }
            else {
                    
                    throw std::runtime_error("Unknown type " + signalSettings.format);
            }

        }
        

    std::cout << "Replaying data (Press Ctrl+C to stop)..." << std::endl;
    if (signalSettings.nsamps <= 0){
        //replay the entire buffer over and over
        std::cout << "Issuing replay command for " << signalSettings.samples_to_replay << " samps in continuous mode..." << std::endl;
        // Replay nsamps, wrapping back to the start of the buffer if nsamps is
        // larger than the buffer size.
       // std::cout << "Replaying data (Press Ctrl+C to stop)..." << std::endl;

        graphSettings.replay_ctrls[signalSettings.singleTX]->config_play(graphSettings.replay_buff_addr, graphSettings.replay_buff_size, graphSettings.replay_chan_vector[signalSettings.singleTX]);
        
        uhd::stream_cmd_t stream_cmd(uhd::stream_cmd_t::STREAM_MODE_START_CONTINUOUS);
        stream_cmd.num_samps = signalSettings.nsamps;
        stream_cmd.stream_now = false;
        stream_cmd.time_spec = graphSettings.time_spec;
        graphSettings.replay_ctrls[signalSettings.singleTX]->issue_stream_cmd(stream_cmd, graphSettings.replay_chan_vector[signalSettings.singleTX]);
        
    }
    else{
        std::cout << graphSettings.replay_ctrls[signalSettings.singleTX]->get_block_id() << " Port: " << graphSettings.replay_chan_vector[signalSettings.singleTX] <<  std::endl;
        std::cout << graphSettings.replay_ctrls[signalSettings.singleTX]->get_block_id() << " Issuing replay command for " << signalSettings.nsamps << " samps..." << std::endl;

         // Replay nsamps, wrapping back to the start of the buffer if nsamps is
        // larger than the buffer size.
        graphSettings.replay_ctrls[signalSettings.singleTX]->config_play(graphSettings.replay_buff_addr, graphSettings.replay_buff_size, graphSettings.replay_chan_vector[signalSettings.singleTX]);
        
        uhd::stream_cmd_t stream_cmd(uhd::stream_cmd_t::STREAM_MODE_NUM_SAMPS_AND_DONE);
        stream_cmd.num_samps = signalSettings.nsamps;
        stream_cmd.stream_now = false;
        stream_cmd.time_spec = graphSettings.time_spec;
        graphSettings.replay_ctrls[signalSettings.singleTX]->issue_stream_cmd(stream_cmd, graphSettings.replay_chan_vector[signalSettings.singleTX]);

    }

    recv_threads.join_all();
    for (int i = 0; i < done_vector.size(); i++){
        done_vector[i] = true;
    }
    write_threads.join_all();
    std::cout << "Complete (Press Ctrl+C to exit)..." << std::endl;
   
    

        
    //If running in continuous mode, call signal handler if user says to stop.     
    if (signalSettings.nsamps <= 0){
        std::signal(SIGINT, &sig_int_handler);
        

        while (not stop_signal_called)
            ;
        std::cout << stop_signal_called << std::endl;

        // Remove SIGINT handler
        std::signal(SIGINT, SIG_DFL);
    }
    else{
        stop_signal_called = true;
    }

    
    
    return EXIT_SUCCESS;
       
       
       





        

}